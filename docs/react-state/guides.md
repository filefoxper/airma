# Guides

The core APIs are [useModel](/react-state/guides?id=usemodel), [useSignal](/react-state/guides?id=usesignal), [useSelector](/react-state/guides?id=useselector), [provide](/react-state/guides?id=provide). Using them from declare API [model](/react-state/guides?id=model) makes state-management more convenient and easier.

## useModel

API `useModel` is the most basic hook in `@airma/react-state`. It can be used in every kind of state-management that supported by `@airma/react-state`.

### Local state-management

It needs a model function and a default state for initializing.

```ts
const instance = useModel(model, defaultState);
```

Example:

```ts
import {useModel} from '@airma/react-state';

const {
    // render data
    count,
    // action method
    increase,
    ......
} = useModel(
    // a model function
    (state:number)=>({
        count: state,
        isNegative: state<0,
        increase(){
            return state+1;
        },
        decrease(){
            return state-1;
        }
    }), 
    // a default state
    props.defaultCount??0
);
```

Just consider it as simplified `useReducer`, that's enough.

### Dynamic store state-management

There are some differences with `Local state-management` usage. 

1. The model function should be replaced by a model key generated by [createKey](/react-state/api?id=createkey).
2. the model key should be assigned to [provide](/react-state/api?id=provide) to generate a store inside this High-Order-Component first.
3. The default state can be ignored, if the model key has a default state.

```ts
// initialized when store was generating.
const storeInstance = useModel(modelKey);
// initialize in render time.
const storeInstance = useModel(modelKey, defaultState);
```

Review [examples](/react-state/concepts?id=key) before.

## useSelector

API [useSelector](/react-state/api?id=useselector) provides a way to select data from `store instance`. When the selected result is changed, it rerenders. That can reduce the frequency of component render. 

```ts
const xxx = useSelector(modelKey, (instance)=>instance.xxx);
```
The last parameter `equalFn` is for telling API how to make judgment about if the selected result has been changed.

```ts
import {pick} from 'lodash';
import {useSelector, shallowEqual} from '@airma/react-state';

const xxx = useSelector(modelKey, (instance)=>pick(instance,['xxx']), shallowEqual);
```

Review [examples](/react-state/concepts?id=key) before.

## createKey and provide

API [provide](/react-state/api?id=provide) is a HOC (Higher-Order-Component). It accepts model keys, and creates a `Context.Provider` wrapper for the component which needs a model store usage. The stores are created from model keys inside every instance of provided component.

API [createKey](/react-state/api?id=createkey) wraps a [model](/react-state/concepts?id=model) to be a unique [key](/react-state/concepts?id=key).

```ts
import {myModel} from './model';
import {createKey, provide} from '@airma/react-state';

const modelKey = createKey(myModel)

const Component = provide(modelKey)(function Component(){
    return ......;
})
```

Want to use more than one stores?


```ts
import {myModel, myModel2} from './model';
import {createKey, provide} from '@airma/react-state';

const key = createKey(myModel, defaultState);

const key2 = createKey(myModel2);

const keys = {key, key2};

const Child = ()=>{
    // link the store with key
    useModel(key);
    return ......;
}

// object style keys
const Component = provide(keys)(function Component(){
    // link the store of key2
    useModel(key2, defaultState);
    return <Child/>
});

// array style keys
const Component1 = provide([key, key2])(function Component1(){
    return <Child/>;
})

// parameter style keys
const Component2 = provide(key, key2)(function Component2(){
    return <Child/>;
})

// parameter style keys, and method style to wrap
const Component3 = provide(key, key2).to(function Component3(){
    return <Child/>;
})
```

Want a Component `provide` style?

```ts
import {myModel} from './model';
import {createKey, Provider} from '@airma/react-state';

const modelKey = createKey(myModel)

const Component = function Component(){
    return (
        <Provider keys={modelKey}>
            ......
        </Provider>
    );
})
```

`Provider` system supports a tree structure find way. When a key finding is started, it always finds store from the most nearest parent Provider to the farthest one from bottom to top.

```ts
import {myModel, myModel2} from './model';
import {createKey, provide} from '@airma/react-state';

const key = createKey(myModel, defaultState);

const key2 = createKey(myModel2);

const Child = provide(key2)(()=>{
    // link the store of key,
    // no matched store in `provide(key2)`,
    // then find in a higher provider,
    // and matched in `provide(key)`
    useModel(key);
    useModel(key2, defaultState);
    return ......;
});

const Component = provide(key)(function Component(){
    useModel(key);
    return <Child/>;
});
```

Want same model, different stores?

```ts
import {myModel} from './model';
import {createKey, provide} from '@airma/react-state';

const key = createKey(myModel);

const key2 = createKey(myModel);

// key and key2 are different keys,
// they are from same model `myModel`,
// that makes they belongs to two different stores
const keys = {key, key2};

const Component = provide(keys)(function Component(){
    return ......;
});
```

## useControlledModel

This API `useControlledModel` can be used in a controlled component, like:

Common model:

```ts
export const toggleModel = (selected:boolean)=>([
    selected,
    ()=>!selected
] as const);
```

Use in un-controlled component:

```ts
import {toggleModel} from '../common/model';
import {useModel} from '@airma/react-state';

const UnControlledCheckbox = ()=>{
    const [
        selected,
        toggle
    ] = useModel(
        toggleModel, 
        false
    );

    return ......;
}
```

Use in controlled component:

```ts
import {toggleModel} from '../common/model';
import {useControlledModel} from '@airma/react-state';

const ControlledCheckbox = (props:{
    checked:boolean,
    onChange:(checked:boolean)=>void
})=>{
    const {checked, onChange} = props;
    const [
        selected,
        toggle
    ] = useControlledModel(
        toggleModel,
        // set the controlled state from props 
        checked, 
        // set the controlled onChange from props
        onChange
    );

    return ......;
}
```

Auto controlled compnent:

```ts
import {toggleModel} from '../common/model';
import {useControlledModel} from '@airma/react-state';

const Checkbox = (props:{
    checked?:boolean,
    onChange?:(checked:boolean)=>void
})=>{
    const {checked, onChange} = props;

    const handleChange = (c: boolean)=>{
        onChange?.(c);
    }
    const instance = useModel(
        toggleModel, 
        checked ?? false
    );
    const cInstance = useControlledModel(
        toggleModel,
        checked ?? false, 
        handleChange
    );

    const isUnControlled = 'checked' in props;

    const [
        selected,
        toggle
    ] = isUnControlled? instance : cInstance;

    return ......;
}
```

API `useControlledModel` accepts a model function, a controlled state and a change callback for notifying a next state.

```ts
const instance = useControlledModel(modelFn, value, onChange)
```

## model

API `model` is a simplify API to use APIs refered before. It accepts a model function, returns a similar model function with APIs inside.

```ts
import {model, provide} from '@airma/react-state';

const toggleModel = model((selected:boolean)=>([
    selected,
    ()=>!selected
] as const));

// build key for dynamic store
const toggleKey = toggleModel.createKey(false);

// build static store
const toggleGlobalStore = toggleModel.createStore(false);

// support initialize static store outside component
toggleGlobalStore.instance(defaultState?);

......
function ChildComponent(){
    const instance = toggleModel.useModel(false);
    const signal = toggleModel.useSignal(false);
    const controlledInstance = toggleModel.useControlledModel(props.checked, props.onChange);
    return ......;
}

......
// dynamic store should be created from key by provider
provide(toggleKey).to(function Component(){
    const [, toggle] = toggleKey.useModel();
    const [signalSelected] = toggleKey.useSignal()();
    const selected = toggleKey.useSelector(([s])=>s);
    // static store can be used directly without any provider
    const selectedInGlobal = toggleGlobalStore.useSelector(([s])=>s);
    return ......;
});
......
function Comp(){
    toggleGlobalStore.useSignal();
    toggleGlobalStore.useModel();
    return ......;
}
```

The `model` API supports to build a static store usage, in that case, no provider is needed.

API `model` is more simple and useful, the output from `model(myModelFn)` is still a model function, it still can be used in other model functions.

The new usage `useSignal` from `v18.4.0` is very useful, take examples and explains in [useSignal](/react-state/guides?id=usesignal) section.

## createField

API `model.createField` helps creating field for model instance. It generates value by calling a `get` method. If a cache value is needed, put some change-able dependencies as an array to the second parameter, that is very helpful when using it with react effect hooks.

```ts
import {model} from '@airma/react-state';

type QueryCondition = {
    name: string;
    page:number;
    pageSize:number;
    fetchVersion:number;
}

const queryModel = model((condition:QueryCondition)=>{
    return {
        ...condition,
        // use condition.fetchVersion as cache dependency,
        // when condition.fetchVersion changes, the cache value will be reloaded.
        // Be careful, the cache field is for model instance outside, so it has no cache effect in model function context.
        // Only when it is get from model instance, and called the get method, the cache effect can be applied.
        query:model.createField(()=>{
            const {name, page, pageSize} = condition;
            return {name, page, pageSize}
        },[condition.fetchVersion]),
        setName(name:string){
            return {
               ...condition,
                name
            }
        },
        setPageInfo(page:number, pageSize:number){
            return {
               ...condition,
                page,
                pageSize
            }
        },
        startFetch(){
            return {
               ...condition,
                fetchVersion:condition.fetchVersion+1
            }
        }
    }
});

const App = ()=>{
    const instance = queryModel.useModel(
        {
            name:'', 
            page:1, 
            pageSize:10, 
            fetchVersion:0
        }
    );
    const { query } = instance;
    const {setName, setPageInfo, startFetch} = instance;

    useEffect(()=>{
        // call the field get method to get value. 
        // {name, page, pageSize}
        fetch(query.get());
    },[query.get()]) // call the field get method to get the cache value, and make cache effect.

    // When the action method setName changes condition.name, the cache field does not response.
    const handleNameChange = (e)=>setName(e.target.value);

    // When action method startFetch changes condition.fetchVersion, the cache field will be reloaded. For its dependency condition.fetchVersion is changed.
    const handleFetch = ()=>startFetch();
    ......
}
```

**Note**, the result generated by calling API `model.createField` should be hang on the instance or dependent by another cache field which has been hang on instance. For the cache effect is given by instance.

You can make a cache field dependent by another one.

```ts
import {model} from '@airma/react-state';

type QueryCondition = {
    name: string;
    page:number;
    pageSize:number;
    fetchVersion:number;
}

const queryModel = model((condition:QueryCondition)=>{

    // This cache field has not been hang on instance,
    // but it is dependent by another cache field.
    // That makes its dependencies passed to that one.
    const pageInfo = model.createField(()=>{
        const {page, pageSize} = condition;
        return {page, pageSize}
    },[condition.page, condition.pageSize]);
    
    return {
        ...condition,
        // It dependents on pageInfo, that makes its dependencies to be condition.page, condition.pageSize and ondition.fetchVersion.
        query: model.createField(()=>{
            const {page, pageSize} = pageInfo.get();
            const {name} = condition;
            return {name, page, pageSize}
        },[condition.fetchVersion, pageInfo]),
        setName(name:string){
            return {
               ...condition,
                name
            }
        },
        setPageInfo(page:number, pageSize:number){
            return {
               ...condition,
                page,
                pageSize
            }
        },
        startFetch(){
            return {
               ...condition,
                fetchVersion:condition.fetchVersion+1
            }
        }
    }
});
```

If there are no dependencies, the get method from field always returns a newest value.

```ts
import {model} from '@airma/react-state';

const countModel = model((count:number)=>([
    model.createField(()=>count),
    ()=>count+1,
    ()=>count-1
] as const));

const App = ()=>{
    const [countField,increase,decrease] = countModel.useModel(0);
    const count = countField.get();

    useEffect(()=>{
        // When count changes, the effect works after 1s.
        // If there is another action happening in this 1s, 
        // the `count` value should be a stale one for the closures effect by ecmascript feature.
        // But the `countField.get()` calling can return a trustable newest value.
        setTimeout(()=>{
            console.log('differ', count, countField.get());
        },1000);
    });

    return (
        <div>
            <button onClick={increase}>+</button>
            {count}
            <button onClick={decrease}>-</button>
        </div>
    );
}
```

**Note**, currently, the field object changes when its dependencies changes, or the model refreshes if there is no dependencies. In feature, the field object will be changeless like action methods, and only the get method returns in field can make changes. 

## ConfigProvider

For `@airma/react-state` uses subscription mode to synchronous state changes, it needs a batch update way to update multiple state changes.

Before react<18.0.0, provide `unstable_batchedUpdates` from `react-dom` to `@airma/react-state` can make subscription state updating work more effectively. 

```ts
import { unstable_batchedUpdates } from 'react-dom';
import { ConfigProvider } from '@airma/react-state';

const config = {batchUpdate: unstable_batchedUpdates};

<ConfigProvider value={config}>
......
</ConfigProvider>
```

## useSignal

### [>=18.4.0]

API [useSignal](/react-state/api?id=usesignal) creates a instance getter callback. Calling this callback can get a newest instance object of model. And only the changes of render usage fields from instance can make component rerender.

```ts
const signal = useSignal(modelFn, defaultState?);
// const signal = useSignal(modelKey);
const instance = signal();
```

Example:

```ts
import {useSignal} from '@airma/react-state';

const counting = (state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){
        return state+1;
    },
    decrease(){
        return state-1;
    }
});

const countingSignal = useSignal(counting, props.defaultCount??0);

// The `isNegative` is added for rerender optimization.
// When `isNegative` changes, it rerenders component.
const {
    // render usage field
    isNegative
} = countingSignal();

if(!isNegative){
    // When `isNegative` is false, and `count` changes, it rerenders component.
    const {
        // render usage field, limited by `isNegative`
        count
    } = countingSignal();
    return ......;
}
```

It is a better choice than [useSelector](/react-state/guides?id=useselector) for reducing the frequency of component render when it works with a store.

A signal callback provides a hook API for adding effects to the action methods.

### signal.useEffect

It is very different with `useEffect` in react. It watches the action methods calling, and executes the effect callbacks after render stages caused by action methods.

```ts
import {useSignal} from '@airma/react-state';

const counting = (state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){
        return state+1;
    },
    decrease(){
        return state-1;
    }
});

const countingSignal = useSignal(counting, props.defaultCount??0);

const {
    isNegative,
    increase,
    decrease
} = countingSignal();

countingSignal.useEffect(()=>{
    // This signal only uses `isNegative` field in render stage, so, only when `isNegative` changes, the effect works.
    console.log('some action method is called');
})
```

The `signal.useEffect` returns filter APIs for narrowing down the calling frequencies.

```ts
import {useSignal} from '@airma/react-state';

const counting = (state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){
        return state+1;
    },
    decrease(){
        return state-1;
    }
});

const countingSignal = useSignal(counting, props.defaultCount??0);

const {
    isNegative,
    increase,
    decrease
} = countingSignal();

countingSignal.useEffect(()=>{
    // Only when increase is called, the effect works.
    console.log('some action method is called');
}).onActions((instance)=>{
    // get the action methods which you want to listen for narrowing change listening frequency. 
    return [instance.increase];
})
```

Use `onChanges` to narrow down the calling frequencies by fields changes.

```ts
import {useSignal} from '@airma/react-state';

const counting = (state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){
        return state+1;
    },
    decrease(){
        return state-1;
    }
});

const countingSignal = useSignal(counting, props.defaultCount??0);

const {
    isNegative,
    increase,
    decrease
} = countingSignal();

countingSignal.useEffect(()=>{
    // Only when count changes, the effect works.
    // No matter if field `count` is used in render stage.
    console.log('some action method is called, that makes render happens');
}).onChanges((instance)=>{
    // returns fields you want to listen for narrowing change listening frequency.
    return [instance.count];
})
```

### signal.useWatch

The difference about `signal.useWatch` with `signal.useEffect` is that `signal.useWatch` listens to the action changes directly, it is not a response to render stage. And no matter if render happens or not, it always executes when the action method is called.

```ts
import {useSignal} from '@airma/react-state';

const counting = (state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){
        return state+1;
    },
    decrease(){
        return state-1;
    }
});

const countingSignal = useSignal(counting, props.defaultCount??0);

const {
    isNegative,
    increase,
    decrease
} = countingSignal();

countingSignal.useWatch(()=>{
    // No matter which field is chhanged, the effect works.
    console.log('some action method is called');
});

countingSignal.useWatch(()=>{
    // To narrow down the calling frequencies, by using `onActions` filter.
    console.log('some action method is called');
}).onActions((instance)=>{
    return [instance.increase];
});

countingSignal.useWatch(()=>{
    // To narrow down the calling frequencies, by using `onChanges` filter.
    console.log('some action method is called');
}).onChanges((instance)=>{
    return [instance.isNegative];
});
```

### useSignal from model

The declare API [model](/react-state/api?id=model) can generate `useSignal` usage too.

```ts
import {model} from '@airma/react-state';

const counting = model((state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){       
        return state+1;
    },
    decrease(){
        return state-1;       
    }
})).createStore();
// Create a static store without initializing state.

const Increase = ()=>{
    // increase is a action method from instance, it is immutable.
    // usSignal returns a instance getter callback, it should be recalled for field usage.
    const {increase} = counting.useSignal()();
    return <button onClick={increase}>+</button>;
};

const Decrease = ()=>{
    // decrease is a action method from instance, it is immutable.
    const {decrease} = counting.useSignal()();
    return <button onClick={decrease}>-</button>;
}

const Count = ()=>{
    const {count} = counting.useSignal()();
    return <span>{count}</span>;
}

const App = ()=>{
    // Use useSignal to initialize state with 0.
    // For this signal is not called, and no field is added into render usage fields, it won't cause component rerender.
    counting.useSignal(0);
    return (
        <div>
            <Count/>
            <Increase/>
            <Decrease/>
        </div>
    );
}
```

### useSignal note:

* The `signal` callback function returns by useSignal is not recommended to be used in a child component `useLayoutEffect stage`. For the render fields usage computing process is shuted down in `useLayoutEffect`, it may add some dirty fields which are not expected to appear in render usage.

Next Page [feature](/react-state/feature).



