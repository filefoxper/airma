# Guides

The core APIs are [useModel](/react-state/guides?id=usemodel), [useSignal](/react-state/guides?id=usesignal), [useSelector](/react-state/guides?id=useselector), [provide](/react-state/guides?id=provide). Using them from declare API [model](/react-state/guides?id=model) makes state-management more convenient and easier.

## useModel

API `useModel` is the most basic hook in `@airma/react-state`. It can be used for both the `Local`and `React.Context` model state-management.

### Local state-management

It needs a model function and a default state for initializing.

```ts
const instance = useModel(model, defaultState);
```

Example:

```ts
import {useModel} from '@airma/react-state';

const {
    // render data
    count,
    // action method
    increase,
    ......
} = useModel(
    // a model function
    (state:number)=>({
        count: state,
        isNegative: state<0,
        increase(){
            return state+1;
        },
        decrease(){
            return state-1;
        }
    }), 
    // a default state
    props.defaultCount??0
);
```

Just consider it as  simplified `useReducer`, that's enough.

### React.Context state-management

There are some differences with `Local state-management`. 

1. The model function should be replaced by a model key generated by [createKey](/react-state/api?id=createkey), and this key should has been used for generating store by [provide](/react-state/api?id=provide) API.
2. The default state can be ignored, if the key has a default state.

```ts
// initialize in store generating
const storeInstance = useModel(modelKey);
// initialize in render time.
const storeInstance = useModel(modelKey, defaultState);
```

Review [examples](/react-state/concepts?id=key) before.

## useSelector

API [useSelector](/react-state/api?id=useselector) provides a way to select data from `store instance`. When the selected result is changed, it rerenders. That can reduce the frequency of component render. 

```ts
const xxx = useSelector(modelKey, (instance)=>instance.xxx);
```
The last parameter `equalFn` for telling API how to make judgment about if the selected result has been changed.

```ts
import {pick} from 'lodash';
import {useSelector, shallowEqual} from '@airma/react-state';

const xxx = useSelector(modelKey, (instance)=>pick(instance,['xxx']), shallowEqual);
```

Review [examples](/react-state/concepts?id=key) before.

## createKey and provide

API [provide](/react-state/api?id=provide) is a HOC (Higher-order Component). It accepts model keys, and creates a `Context.Provider` wrapper for the component which needs a model store usage. The store is created from model keys inside every instance of provided component.

API [createKey](/react-state/api?id=createkey) wraps a [model](/react-state/concepts?id=model) to be a unique [key](/react-state/concepts?id=key).

```ts
import {myModel} from './model';
import {createKey, provide} from '@airma/react-state';

const modelKey = createKey(myModel)

const Component = provide(modelKey)(function Component(){
    return ......;
})
```

Want to use more than one stores?


```ts
import {myModel, myModel2} from './model';
import {createKey, provide} from '@airma/react-state';

const key = createKey(myModel, defaultState);

const key2 = createKey(myModel2);

const keys = {key, key2};

const Child = ()=>{
    // link the store of key
    useModel(keys.key);
    return ......;
}

// object style keys
const Component = provide(keys)(function Component(){
    // link the store of key2
    useModel(key2, defaultState);
    return <Child/>
});

// array style keys
const Component1 = provide([key, key2])(function Component1(){
    return <Child/>;
})
```

Want a Component `provide` style?

```ts
import {myModel} from './model';
import {createKey, Provider} from '@airma/react-state';

const modelKey = createKey(myModel)

const Component = function Component(){
    return (
        <Provider keys={modelKey}>
            ......
        </Provider>
    );
})
```

`Provider` system uses a distributed store persist strategy, these distributed stores are composed to be a tree structure. So, a model key always finds Provider store from nearest to the top one.

```ts
import {myModel, myModel2} from './model';
import {createKey, provide} from '@airma/react-state';

const key = createKey(myModel, defaultState);

const key2 = createKey(myModel2);

const Child = provide(key2)(()=>{
    // link the store of key,
    // no matched store in `provide(key2)`,
    // then find in a higher provider,
    // and matched in `provide(key)`
    useModel(key);
    useModel(key2, defaultState);
    return ......;
});

const Component = provide(key)(function Component(){
    useModel(key);
    return <Child/>;
});
```

Want same model, different stores?

```ts
import {myModel} from './model';
import {createKey, provide} from '@airma/react-state';

const key = createKey(myModel);

const key2 = createKey(myModel);

// key and key2 are different keys,
// they are from same model `myModel`,
// that makes two different stores
const keys = {key, key2};

const Component = provide(keys)(function Component(){
    return ......;
});
```

## useControlledModel

This API `useControlledModel` can be used in controlled component, like:

Common model:

```ts
export const toggleModel = (selected:boolean)=>([
    selected,
    ()=>!selected
] as const);
```

Use in un-controlled component:

```ts
import {toggleModel} from '../common/model';
import {useModel} from '@airma/react-state';

const UnControlledCheckbox = ()=>{
    const [
        selected,
        toggle
    ] = useModel(
        toggleModel, 
        false
    );

    return ......;
}
```

Use in controlled component:

```ts
import {toggleModel} from '../common/model';
import {useControlledModel} from '@airma/react-state';

const ControlledCheckbox = (props:{
    checked:boolean,
    onChange:(checked:boolean)=>void
})=>{
    const {checked, onChange} = props;
    const [
        selected,
        toggle
    ] = useControlledModel(
        toggleModel,
        // set the controlled state from props 
        checked, 
        // set the controlled onChange from props
        onChange
    );

    return ......;
}
```

Auto controlled compnent:

```ts
import {toggleModel} from '../common/model';
import {useControlledModel} from '@airma/react-state';

const Checkbox = (props:{
    checked?:boolean,
    onChange?:(checked:boolean)=>void
})=>{
    const {checked, onChange} = props;

    const handleChange = (c: boolean)=>{
        onChange?.(c);
    }
    const instance = useModel(
        toggleModel, 
        checked ?? false
    );
    const cInstance = useControlledModel(
        toggleModel,
        checked ?? false, 
        handleChange
    );

    const isUnControlled = 'checked' in props;

    const [
        selected,
        toggle
    ] = isUnControlled? instance : cInstance;

    return ......;
}
```

API `useControlledModel` accepts a model function, a controlled state and a change callback for this controlled state as parameters.

```ts
const instance = useControlledModel(modelFn, value, onChange)
```

## model

API `model` is a simplify API to use APIs refered before. It accepts a model function, returns a similar model function with APIs inside.

```ts
import {model} from '@airma/react-state';

const toggleModel = model((selected:boolean)=>([
    selected,
    ()=>!selected
] as const));

const toggleStore = toggleModel.createStore(false);

const toggleGlobalStore = toggleStore.asGlobal();
......
const instance =toggleModel.useModel(false);
const signal = toggleModel.useSignal(false);
const controlledInstance = toggleModel.useControlledModel(props.checked, props.onChange);
......
toggleStore.provideTo(function Component(){
    const [, toggle] = toggleStore.useModel();
    const [signalSelected] = toggleStore.useSignal()();
    const selected = toggleStore.useSelector(([s])=>s);
    const selectedInGlobal = toggleGlobalStore.useSelector(([s])=>s);
    return ......;
});
......
function Comp(){
    toggleGlobalStore.useSignal();
    toggleGlobalStore.useModel();
    return ......;
}
```

The `model` API support global store usage, in that case, no provider is needed.

Want more store in one provider?

```ts
import {model} from '@airma/react-state';

const toggleStore = model((selected:boolean)=>([
    selected,
    ()=>!selected
] as const)).createStore(false);

const countStore = model((count:number)=>([
    count,
    ()=>count+1,
    ()=>count-1
] as const)).createStore(0);

......
toggleStore.with(countStore,...).provideTo(
    function Component(){
        const [, toggle] = toggleStore.useModel();
        const selected = toggleStore.useSelector(([s])=>s);
        const [count, increase, decrease] = countStore.useModel();
        return ......;
    }
);
......
```

API `model` is more simple and useful, the output from `model(myModelFn)` is still a model function, it still can be used in other model functions.

The new usage `useSignal` from `v18.4.0` is very useful, take examples and explains in [useSignal](/react-state/guides?id=usesignal) section.

## createField

API `model.createField` helps creating field for model instance. It generates value by calling a `get` method. If a cache value is needed, put some change-able dependencies as an array to the second parameter, that is very helpful when using it with react effect hooks.

```ts
import {model} from '@airma/react-state';

type QueryCondition = {
    name: string;
    page:number;
    pageSize:number;
    fetchVersion:number;
}

const queryModel = model((condition:QueryCondition)=>{
    return {
        ...condition,
        // use condition.fetchVersion as cache dependency,
        // when condition.fetchVersion changes, the cache value will be reloaded.
        // Be careful, the cache field is for model instance, so it has no cache effect in model function context.
        // Only when it is get from model instance, and called the get method, the cache effect can be applied.
        query:model.createField(()=>{
            const {name, page, pageSize} = condition;
            return {name, page, pageSize}
        },[condition.fetchVersion]),
        setName(name:string){
            return {
               ...condition,
                name
            }
        },
        setPageInfo(page:number, pageSize:number){
            return {
               ...condition,
                page,
                pageSize
            }
        },
        startFetch(){
            return {
               ...condition,
                fetchVersion:condition.fetchVersion+1
            }
        }
    }
});

const App = ()=>{
    const instance = queryModel.useModel(
        {
            name:'', 
            page:1, 
            pageSize:10, 
            fetchVersion:0
        }
    );
    const { query } = instance;
    const {setName, setPageInfo, startFetch} = instance;

    useEffect(()=>{
        // call the cache field get method to get the cache value. 
        // {name, page, pageSize}
        fetch(query.get());
    },[query.get()]) // call the cache field get method to get the cache value, and make cache effect.

    // When the action method setName changes condition.name, the cache field does not response.
    const handleNameChange = (e)=>setName(e.target.value);

    // When action method startFetch changes condition.fetchVersion, the cache field will be reloaded. For its dependency condition.fetchVersion is changed.
    const handleFetch = ()=>startFetch();
    ......
}
```

**Note**, the result generated by calling API `model.createField` should be hang on the instance or dependent by another cache field which has been hang on instance. For the cache effect is given by instance.

You can make a cache field dependent another one.

```ts
import {model} from '@airma/react-state';

type QueryCondition = {
    name: string;
    page:number;
    pageSize:number;
    fetchVersion:number;
}

const queryModel = model((condition:QueryCondition)=>{

    // This cache field has not been hang on instance,
    // but it is dependent by another cache field.
    // That makes its dependencies passed to that one.
    const pageInfo = model.createField(()=>{
        const {page, pageSize} = condition;
        return {page, pageSize}
    },[condition.page, condition.pageSize]);
    
    return {
        ...condition,
        // It dependents on pageInfo, that makes its dependencies to be condition.page, condition.pageSize and ondition.fetchVersion.
        query:model.createField(()=>{
            const {page, pageSize} = pageInfo.get();
            const {name} = condition;
            return {name, page, pageSize}
        },[condition.fetchVersion, pageInfo]),
        setName(name:string){
            return {
               ...condition,
                name
            }
        },
        setPageInfo(page:number, pageSize:number){
            return {
               ...condition,
                page,
                pageSize
            }
        },
        startFetch(){
            return {
               ...condition,
                fetchVersion:condition.fetchVersion+1
            }
        }
    }
});
```

## ConfigProvider

For `@airma/react-state` uses subscription mode to synchronous state changes, it needs a batch update way to update multiple state changes.

Before react<18.0.0, provide `unstable_batchedUpdates` from `react-dom` to `@airma/react-state` can make subscription state updating work more effectively. 

```ts
import { unstable_batchedUpdates } from 'react-dom';
import { ConfigProvider } from '@airma/react-state';

const config = {batchUpdate: unstable_batchedUpdates};

<ConfigProvider value={config}>
......
</ConfigProvider>
```

## useSignal

### [>=18.4.0]

API [useSignal](/react-state/api?id=usesignal) creates a instance getter callback. Calling this callback can get a newest instance object of model. And only the changes of render usage fields from instance can make component rerender.

```ts
const signal = useSignal(modelFn, defaultState?);
// const signal = useSignal(modelKey);
const instance = signal();
```

Example:

```ts
import {useSignal} from '@airma/react-state';

const counting = (state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){
        return state+1;
    },
    decrease(){
        return state-1;
    }
});

const countingSignal = useSignal(counting, props.defaultCount??0);

// The `isNegative` is added for rerender optimization.
// When `isNegative` changes, it rerenders component.
const {
    // render usage field
    isNegative
} = countingSignal();

if(!isNegative){
    // When `isNegative` is false, and `count` changes, it rerenders component.
    const {
        // render usage field, limited by `isNegative`
        count
    } = countingSignal();
    return ......;
}
```

It is a better choice than [useSelector](/react-state/guides?id=useselector) for reducing the frequency of component render when it works with a store.

A signal callback provides a hook API for adding effects to the action methods.

### signal.useEffect

It is very different with `useEffect` in react. It watches the action methods calling, and executes the effect callbacks which listened with the calling action method.

```ts
import {useSignal} from '@airma/react-state';

const counting = (state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){
        return state+1;
    },
    decrease(){
        return state-1;
    }
});

const countingSignal = useSignal(counting, props.defaultCount??0);

const {
    isNegative,
    increase,
    decrease
} = countingSignal();

countingSignal.useEffect(()=>{
    // No matter increase or decrease is called, the effect works.
    console.log('some action method is called');
})
```

The `signal.useEffect` returns an filter API for narrowing down the action methods to be watched.

```ts
import {useSignal} from '@airma/react-state';

const counting = (state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){
        return state+1;
    },
    decrease(){
        return state-1;
    }
});

const countingSignal = useSignal(counting, props.defaultCount??0);

const {
    isNegative,
    increase,
    decrease
} = countingSignal();

countingSignal.useEffect(()=>{
    // Only when increase is called, the effect works.
    console.log('some action method is called');
}).onActions((instance)=>{
    // get the action methods which you want to listen from instance 
    return [instance.increase];
})
```

### useSignal from model

The declare API [model](/react-state/api?id=model) can generate `useSignal` usage too.

```ts
import {model} from '@airma/react-state';

const counting = model((state:number)=>({
    count: state,
    isNegative: state<0,
    increase(){       
        return state+1;
    },
    decrease(){
        return state-1;       
    }
})).createStore().static();
// Create a static store without initializing state.

const Increase = ()=>{
    // increase is a action method from instance, it is immutable.
    // usSignal returns a instance getter callback, it should be recalled for field usage.
    const {increase} = counting.useSignal()();
    return <button onClick={increase}>+</button>;
};

const Decrease = ()=>{
    // decrease is a action method from instance, it is immutable.
    const {decrease} = counting.useSignal()();
    return <button onClick={decrease}>-</button>;
}

const Count = ()=>{
    const {count} = counting.useSignal()();
    return <span>{count}</span>;
}

const App = ()=>{
    // Use useSignal to initialize state with 0.
    // For this signal is not called, and no field is added into render usage fields, it won't cause component rerender.
    counting.useSignal(0);
    return (
        <div>
            <Count/>
            <Increase/>
            <Decrease/>
        </div>
    );
}
```

### useSignal note:

* The `signal` callback function returns by useSignal is not recommended to be used in a child component `useLayoutEffect stage`. For the render fields usage computing process is shuted down in `useLayoutEffect`, it may add some dirty fields which are not expected to appear in render usage.

Next Page [feature](/react-state/feature).



