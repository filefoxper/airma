# API

## React-State APIs

### createKey

[method API] It is used to create a model key for scope accesss, [ref](/react-state/api?id=createkey).

```ts
declare type AirReducer<S>=(state:S)=>any;

export declare function createKey<
  S, 
  R extends AirReducer<S>
>(
  model: R,
  defaultState: S
): R;
```

### useModel

[hook API] It is used to initialize and update instance object generated from model function, [ref](/react-state/api?id=usemodel).

```ts
declare type AirReducer<S>=(state:S)=>any;

export declare function useModel<
  S,
  R extends AirReducer<S>
>(
  modelOrKey: R,
  state?: S,
): ReturnType<R>;
```

### useSignal

[hook API] It is used to initialize and update instance object generated from model function, [ref](/react-state/api?id=usesignal).

```ts
declare type AirReducer<S>=(state:S)=>any;

export declare function useSignal<
  S,
  R extends AirReducer<S>
>(
  modelOrKey: R,
  state?: S,
): ()=>ReturnType<R>;
```

## ~~useStaticModel~~

The different with useModel is that useStaticModel can change store state, but can not subscribe store. It is useful for reducing the render frequency. [ref](/react-state/api?id=usestaticmodel). 

```ts
function useStaticModel(modelKey, defaultState?): instance
```

Parameters:

* modelKey - It should be a model key, created by [createKey](/react-state/api?id=createkey) API.
* defaultState - Optional, a default state for model initializing.

Returns

* A instance object (Proxy object). Call the action method from instance, can generate a next state, and refreshes instance in store.


### useControlledModel

[hook API] It is used to connect model function instance with an exist state system, like: `useState`, [ref](/react-state/api?id=usecontrolledmodel).

```ts
declare type AirReducer<S>=(state:S)=>any;

export declare function useControlledModel<
  S,
  R extends AirReducer<S>
>(
  model: R,
  state: S,
  onChange: (s: S) => any
): ReturnType<R>;
```

### useSelector

[hook API] It is used to select data from instance from a scope store, and if the selected data has not changed, it should not trigger render, it is always used for enhance render performance, [ref](/react-state/api?id=useselector).

```ts
declare type AirReducer<S>=(state:S)=>any;

export declare function useSelector<
  S,
  R extends AirReducer<S>,
  C extends (instance: ReturnType<R>) => any
>(
  key: ModelKey<R>,
  selector: C,
  equalFn?: (c: ReturnType<C>, n: ReturnType<C>) => boolean
): ReturnType<C>;
```

### ~~useRealtimeInstance~~

It extracts a realtime instance from useModel instance object. 

The fields of instance generated by useModel are static in render time. The fields of realtime instance are dynamic in render time. [ref](/react-state/api?id=userealtimeinstance). 

```ts
function useRealtimeInstance<T>(instance: T): T;
```

### model

It is a simplified API for use `hooks` in `@airma/react-state`. It also can be used for checking the typescript problems about the parameter `model function`. [ref](/react-state/api?id=model). 

```ts
interface GlobalStoreApi {
  useModel,
  useSelector
}

interface StoreApi {
  key,
  with:(
    ...stores: (StoreApi | ModelKey)[]
  ) => StoreApi,
  asGlobal: () => GlobalStoreApi,
  provide,
  provideTo: (
    component: ComponentType
  ) => typeof component,
  Provider: FC<{ children?: ReactNode }>,
  useModel,
  useSelector
}

interface Api {
  useModel,
  useControlledModel,
  createStore: (defaultState?) => StoreApi;
}

function model(modelFn): (typeof modelFn) & Api;
```

### shallowEqual

[method API] It is used to compare if two objects are equality with shallow comparation, [ref](/react-state/api?id=shallowequal).

```ts
export declare function shallowEqual<R>(prev: R, current: R): boolean;
```

## React-effect APIs

### createSessionKey

[method API] It is used to create a session key for scope accesss, [ref](/react-effect/api?id=createsessionkey).

```ts
export declare function createSessionKey<
  E extends (...params: any[]) => Promise<any>
>(
  effectCallback: E,
  queryType:'query'|'mutation'
): SessionKey<E>;
```

### Strategy

[collection API] It is an often used strategies collection for `useQuery` and `useMutation`, [ref](/react-effect/api?id=strategy).

### useQuery

[hook API] It is used to maintain a query type asynchronous state, [ref](/react-effect/api?id=usequery).

```ts
export declare function useQuery<
  D extends PromiseCallback<any> | SessionKey<any>
>(
  promiseCallbackOrSessionKey: D,
  config: QueryConfig
): SessionResult<D>;
```

### useMutation

[hook API] It is used to maintain a mutation type asynchronous state, [ref](/react-effect/api?id=usemutation).

```ts
export declare function useMutation<
  D extends PromiseCallback<any> | SessionKey<any>
>(
  promiseCallbackOrSessionKey: D,
  config: MutationConfig
): SessionResult<D>;
```

### useSession

[hook API] It is used to pick session state by session key from a scope store, [ref](/react-effect/api?id=usesession).

```ts
export declare function useSession<D extends SessionKey>(
  sessionKey: D,
  config?: { loaded?: boolean; sessionType?: SessionType } | SessionType
): [SessionState, () => void];
```

### useLoadedSession

[hook API] It is a mutation api from `useSession` with a default `loaded: true` config, [ref](/react-effect/api?id=useloadedsession).

```ts
export declare function useLoadedSession<D extends SessionKey>(
  sessionKey: D,
  config?: UseSessionConfig | SessionType
): [LoadedSessionState, () => void];
```

### useResponse

[hook API] It is used to call effect method about session state resolved or rejected effect happens, [ref](/react-effect/api?id=useresponse).

```ts
export declare interface useResponse<T> {
  (
    process: (state: SessionState<T>) => any,
    sessionState: SessionState<T>
  ): void;
  success: (
    process: (data: T, sessionState: SessionState<T>) => any,
    sessionState: SessionState<T>
  ) => void;
  error: (
    process: (error: unknown, sessionState: SessionState) => any,
    sessionState: SessionState
  ) => void;
}
```

### session

It is a function for wrapping a promise callback to be a API collection. [ref](/react-effect/api?id=session).

```ts
type StaticStoreApi = {
  useQuery(
    variablesOrConfig
  ):[sessionState, trigger, execute];
  useMutation(
    variablesOrConfig
  ):[sessionState, trigger, execute];
  useSession():[sessionState, trigger];
  useLoadedSession():[sessionState, trigger];
};

type StoreApi = {
  asGlobal(): StaticStoreApi;
  provideTo<P extends object>(
    component: ComponentType<P>
  ):ComponentType<P>;
  Provider:FunctionComponent<{
    value: ModelKeys, 
    children?: ReactNode
  }>;
  with(...stores:(StoreApi|ModelKey)[]);
  useQuery(
    variablesOrConfig
  ):[sessionState, trigger, execute];
  useMutation(
    variablesOrConfig
  ):[sessionState, trigger, execute];
  useSession():[sessionState, trigger];
  useLoadedSession():[sessionState, trigger];
};

type Api = {
  createStore():StoreApi;
  useQuery(
    variablesOrConfig
  ):[sessionState, trigger, execute];
  useMutation(
    variablesOrConfig
  ):[sessionState, trigger, execute];
};

function session(
  promiseCallback, 
  sessionType: 'query' | 'mutation'
): Api
```

### useIsFetching

[hook API] It is used to detect if there are some useQuery or useMutation are still fetching, [ref](/react-effect/api?id=useisfetching).

```ts
export declare function useIsFetching(
  ...sessionStates: (AbstractSessionState | AbstractSessionResult)[]
): boolean;
```

### useLazyComponent

It is used for loading asynchronous component when all dependency sessions have finished once.[ref](/react-effect/api?id=uselazycomponent).

```ts
function useLazyComponent(
  componentLoader, 
  ...sessionStates
): LazyComponent
```

## Common APIs

### provide

[common HOC API] It is used to connect component into a `Provider` component, so we can use scope store to get and share state changes in any where. For `@airma/react-effect` is using a same store system with `@airma/react-state`, so, we make them combined to be one. [state ref](/react-state/api?id=provide) and [effect ref](/react-effect/api?id=provide)

```ts
export declare function provide(
  keys: ModelKeys
): <P extends Record<string, any>>(
  component: FunctionComponent<P> | NamedExoticComponent<P>
) => typeof component;
```

### Provider

[common Component API] It is the `Provider` component which is created by `provide` API, you can set `value` props to create store, and use keys inside to access to store. It is a combined API too. [state ref](/react-state/api?id=storeprovider) and [effect ref](/react-effect/api?id=sessionprovider)

```ts
export declare const Provider: FC<{
  value: ModelKeys;
  children?: ReactNode;
}>;
```

### ConfigProvider

[common Component API] It is used to config the API features about `@airma/react-state` and `@airma/react-effect`. [state ref](/react-state/api?id=configprovider) and [effect ref](/react-effect/api?id=configprovider)

```ts
export declare type GlobalConfig = {
  batchUpdate?: (callback: () => void) => void;
  useGlobalFetching?: boolean;
  strategy?: (
    strategy: (StrategyType | null | undefined)[],
    type: SessionType
  ) => (StrategyType | null | undefined)[];
};

export declare const ConfigProvider: FC<{
  value: GlobalConfig;
  children?: ReactNode;
}>;
```

## React-Hooks APIs

### usePersistFn

```ts
export declare function usePersistFn<T extends (...args: any[]) => any>(
  callback: T
): T;
```

This hook is created for replacing `useCallback`, if you want to create a persist callback.

```ts
import {memo} from 'react';
import {usePersistFn} from '@airma/react-hooks-core';

const App = memo((props: {onChange: (value:string)=>void})=>{
    return ...;
});

const Layout = ()=>{
    const call = usePersistFn((v: string)=>{});

    return <App onChange={call}/>
}
```

### useMount

```ts
export declare function useMount(callback: () => (() => void) | void): void;
```

This hook is created for listen the mount effect of functional component.

### useUpdate

```ts
export declare function useUpdate<T extends any[]>(
  callback: (prevDeps: typeof deps) => (() => void) | void,
  deps?: T
): void;
```

This hook is created for listen the update effect of functional component.

```ts
import {memo, useState} from 'react';
import {useUpdate} from '@airma/react-hooks-core';

const App = memo((props: {value:number})=>{

    const [count, setCount] = useState(props.value);

    useUpdate((prev)=>{
        if(!prev){
            return;
        }
        const [prevValue] = prev;
        console.log(prevValue)
    }, [props.value]);

    return ...;
});
```

### useRefresh

```ts
export declare function useRefresh<T extends (...args: any[]) => any>(
  method: T,
  params:
    | Parameters<T>
    | {
        refreshDeps?: any[];
        variables: Parameters<T>;
      }
): void;
```

This hook helps you call a `function` when the parameters have been changed.

```ts
import {useEffect, useState} from 'react';
import {useRefresh} from '@airma/react-hooks-core';

function useIntervalCountDown() {
    const [count, setCount] = useState(60);
    const [s, setS] = useState(count);
    useEffect(()=>{
        const id = window.setInterval(()=>{
            setCount(c=>c-1);
        },1000);
        return ()=> {
            window.clearInterval(id);
        }
    },[]);
    
    useRefresh((seconds)=>setS(seconds<0?0:seconds), [count]);
    
    return s+'s';
}
```

### useUnmount

```ts
export declare function useUnmount(destroy: () => void): void;
```

This hook is created for listen the unmount effect of functional component.

### useDebounceFn

```ts
declare type Promisify<F extends (...args: any[]) => any> = F extends (
  ...args: infer A
) => infer R
  ? (...args: A) => Promise<R>
  : never;

export declare function useDebounceFn<F extends (...args: any[]) => any>(
  fn: F,
  option: number | { lead?: boolean; ms: number }
): Promisify<F>;
```

This hook API wraps a callback to be a debounce callback, the wrapped callback returns a promise object.

#### Parameters

* **fn** - Callback for running.
* **option** - Debounce millisecond or an Option object. If the option.lead is true, the wrapped callback calls at the beginning time.

#### Returns

A wrapped debounce callback.  
