# API

## createKey

[method API] It is used to create a model key for scope accesss, [ref](/react-state/api?id=createkey).

```ts
declare type AirReducer<S>=(state:S)=>any;

export declare function createKey<
  S, 
  R extends AirReducer<S>
>(
  model: R,
  defaultState: S
): R;
```

## useModel

[hook API] It is used to initialize and update instance object generated from model function, [ref](/react-state/api?id=usemodel).

```ts
declare type AirReducer<S>=(state:S)=>any;

export declare function useModel<
  S,
  R extends AirReducer<S>
>(
  model: R,
  state?: S,
  option?: {
    refresh?: boolean;
    autoLink?: boolean;
    realtimeInstance?: boolean;
    useDefaultState?: boolean;
  }
): ReturnType<R>;
```

## useControlledModel

[hook API] It is used to connect model function instance with an exist state system, like: `useState`, [ref](/react-state/api?id=usecontrolledmodel).

```ts
declare type AirReducer<S>=(state:S)=>any;

export declare function useControlledModel<
  S,
  R extends AirReducer<S>
>(
  model: R,
  state: S,
  onChange: (s: S) => any
): ReturnType<R>;
```

## useRealtimeInstance

[hook API] It is used to pick a realtime change instance from `instance` which is generated by `useModel`, [ref](/react-state/api?id=userealtimeinstance).

```ts
export declare function useRealtimeInstance<T>(instance: T): T;
```

## useSelector

[hook API] It is used to select data from instance from a scope store, and if the selected data has not changed, it should not trigger render, it is always used for enhance render performance, [ref](/react-state/api?id=useselector).

```ts
declare type AirReducer<S>=(state:S)=>any;

export declare function useSelector<
  S,
  R extends AirReducer<S>,
  C extends (instance: ReturnType<R>) => any
>(
  factoryModel: R,
  selector: C,
  equalFn?: (c: ReturnType<C>, n: ReturnType<C>) => boolean
): ReturnType<C>;
```

## createSessionKey

[method API] It is used to create a session key for scope accesss, [ref](/react-effect/api?id=createsessionkey).

```ts
export declare function createSessionKey<
  E extends (...params: any[]) => Promise<any>
>(
  effectCallback: E,
  queryType:'query'|'mutation'
): SessionKey<E>;
```

## Strategy

[collection API] It is an often used strategies collection for `useQuery` and `useMutation`, [ref](/react-effect/api?id=strategy).

## useQuery

[hook API] It is used to maintain a query type asynchronous state, [ref](/react-effect/api?id=usequery).

```ts
export declare function useQuery<
  D extends PromiseCallback<any> | SessionKey<any>
>(
  callback: D,
  config: QueryConfig
): SessionResult<D>;
```

## useMutation

[hook API] It is used to maintain a mutation type asynchronous state, [ref](/react-effect/api?id=usemutation).

```ts
export declare function useMutation<
  D extends PromiseCallback<any> | SessionKey<any>
>(
  callback: D,
  config: MutationConfig
): SessionResult<D>;
```

## useSession

[hook API] It is used to pick session state by session key from a scope store, [ref](/react-effect/api?id=usesession).

```ts
export declare function useSession<D extends SessionKey>(
  sessionKey: D,
  config?: { loaded?: boolean; sessionType?: SessionType } | SessionType
): [SessionState, () => void];
```

## useLoadedSession

[hook API] It is a mutation api from `useSession` with a default `loaded: true` config, [ref](/react-effect/api?id=useloadedsession).

```ts
export declare function useLoadedSession<D extends SessionKey>(
  sessionKey: D,
  config?: UseSessionConfig | SessionType
): [LoadedSessionState, () => void];
```

## useResponse

[hook API] It is used to call effect method about session state resolved or rejected effect happens, [ref](/react-effect/api?id=useresponse).

```ts
export declare interface useResponse<T> {
  (
    process: (state: SessionState<T>) => any,
    sessionState: SessionState<T>
  ): void;
  success: (
    process: (data: T, sessionState: SessionState<T>) => any,
    sessionState: SessionState<T>
  ) => void;
  error: (
    process: (error: unknown, sessionState: SessionState) => any,
    sessionState: SessionState
  ) => void;
}
```

## useIsFetching

[hook API] It is used to detect if there are some useQuery or useMutation are still fetching, [ref](/react-effect/api?id=useisfetching).

```ts
export declare function useIsFetching(
  ...sessionStates: (AbstractSessionState | AbstractSessionResult)[]
): boolean;
```

## provide

[common HOC API] It is used to connect component into a `Provider` component, so we can use scope store to get and share state changes in any where. For `@airma/react-effect` is using a same store system with `@airma/react-state`, so, we make them combined to be one. [state ref](/react-state/api?id=provide) and [effect ref](/react-effect/api?id=provide)

```ts
export declare function provide(
  keys: ModelKeys
): <P extends Record<string, any>>(
  component: FunctionComponent<P> | NamedExoticComponent<P>
) => typeof component;
```

## Provider

[common Component API] It is the `Provider` component which is created by `provide` API, you can set `value` props to create store, and use keys inside to access to store. It is a combined API too. [state ref](/react-state/api?id=storeprovider) and [effect ref](/react-effect/api?id=sessionprovider)

```ts
export declare const Provider: FC<{
  value: ModelKeys;
  children?: ReactNode;
}>;
```

## ConfigProvider

[common Component API] It is used to config the API features about `@airma/react-state` and `@airma/react-effect`. [state ref](/react-state/api?id=configprovider) and [effect ref](/react-effect/api?id=configprovider)

```ts
export declare type GlobalConfig = {
  batchUpdate?: (callback: () => void) => void;
  useGlobalFetching?: boolean;
  strategy?: (
    strategy: (StrategyType | null | undefined)[],
    type: SessionType
  ) => (StrategyType | null | undefined)[];
};

export declare const ConfigProvider: FC<{
  value: GlobalConfig;
  children?: ReactNode;
}>;
```

## shallowEqual

[method API] It is used to compare if two objects are equality with shallow comparation.

```ts
export declare function shallowEqual<R>(prev: R, current: R): boolean;
```

## usePersistFn

```ts
export declare function usePersistFn<T extends (...args: any[]) => any>(
  callback: T
): T;
```

This hook is created for replacing `useCallback`, if you want to create a persist callback.

```ts
import {memo} from 'react';
import {usePersistFn} from '@airma/react-hooks-core';

const App = memo((props: {onChange: (value:string)=>void})=>{
    return ...;
});

const Layout = ()=>{
    const call = usePersistFn((v: string)=>{});

    return <App onChange={call}/>
}
```

## useMount

```ts
export declare function useMount(callback: () => (() => void) | void): void;
```

This hook is created for listen the mount effect of functional component.

## useUpdate

```ts
export declare function useUpdate<T extends any[]>(
  callback: (prevDeps: typeof deps) => (() => void) | void,
  deps?: T
): void;
```

This hook is created for listen the update effect of functional component.

```ts
import {memo, useState} from 'react';
import {useUpdate} from '@airma/react-hooks-core';

const App = memo((props: {value:number})=>{

    const [count, setCount] = useState(props.value);

    useUpdate((prev)=>{
        if(!prev){
            return;
        }
        const [prevValue] = prev;
        console.log(prevValue)
    }, [props.value]);

    return ...;
});
```

## useRefresh

```ts
export declare function useRefresh<T extends (...args: any[]) => any>(
  method: T,
  params:
    | Parameters<T>
    | {
        refreshDeps?: any[];
        variables: Parameters<T>;
      }
): void;
```

This hook helps you call a `function` when the parameters have been changed.

```ts
import {useEffect, useState} from 'react';
import {useRefresh} from '@airma/react-hooks-core';

function useIntervalCountDown() {
    const [count, setCount] = useState(60);
    const [s, setS] = useState(count);
    useEffect(()=>{
        const id = window.setInterval(()=>{
            setCount(c=>c-1);
        },1000);
        return ()=> {
            window.clearInterval(id);
        }
    },[]);
    
    useRefresh((seconds)=>setS(seconds<0?0:seconds), [count]);
    
    return s+'s';
}
```

## useUnmount

```ts
export declare function useUnmount(destroy: () => void): void;
```

This hook is created for listen the unmount effect of functional component.
