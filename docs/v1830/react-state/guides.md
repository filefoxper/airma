# Guides

The core APIs are [useModel](/react-state/guides?id=usemodel), [useSelector](/react-state/guides?id=useselector), [provide](/react-state/guides?id=provide). The common entrance of these APIs is [model](/react-state/guides?id=model).

## useModel

API `useModel` is the most basic hook in `@airma/react-state`. It can be used for both the `Local`and `React.Context` model state-management.

### Local state-management

It needs a model function and a default state for initializing.

```ts
const instance = useModel(model, defaultState);
```

Example:

```ts
import {useModel} from '@airma/react-state';

const {
    // render data
    count,
    // action method
    increase,
    ......
} = useModel(
    // a model function
    (state:number)=>({
        count: state,
        isNegative: state<0,
        increase(){
            return state+1;
        },
        decrease(){
            return state-1;
        }
    }), 
    // a default state
    props.defaultCount??0
);
```

Just consider it as  simplified `useReducer`, that's enough.

### React.Context state-management

There are some differences with `Local state-management`. 

1. The model function should be replaced by a model key generated by [createKey](/react-state/api?id=createkey), and this key should has been used for generating store by [provide](/react-state/api?id=provide) API.
2. The default state can be ignored, if the key has a default state.

```ts
// initialize in store generating
const storeInstance = useModel(modelKey);
// initialize in render time.
const storeInstance = useModel(modelKey, defaultState);
```

Review [examples](/react-state/concepts?id=key) before.

## useSelector

API `useSelector` provides a way to select data from `store instance`. When the selected result is changed, it rerenders. That can reduce the frequency of component render. 

```ts
const xxx = useSelector(modelKey, (instance)=>instance.xxx);
```
The last parameter `equalFn` for telling API how to make judgment about if the selected result has been changed.

```ts
import {pick} from 'lodash';
import {useSelector, shallowEqual} from '@airma/react-state';

const xxx = useSelector(modelKey, (instance)=>pick(instance,['xxx']), shallowEqual);
```

Review [examples](/react-state/concepts?id=key) before.

## createKey and provide

API [provide](/react-state/api?id=provide) is a HOC (Higher-order Component). It accepts model keys, and creates a `Context.Provider` wrapper for the component which needs a model store usage. The store is created from model keys inside every instance of provided component.

API [createKey](/react-state/api?id=createkey) wraps a [model](/react-state/concepts?id=model) to be a unique [key](/react-state/concepts?id=key).

```ts
import {myModel} from './model';
import {createKey, provide} from '@airma/react-state';

const modelKey = createKey(myModel)

const Component = provide(modelKey)(function Component(){
    return ......;
})
```

Want to use more than one stores?


```ts
import {myModel, myModel2} from './model';
import {createKey, provide} from '@airma/react-state';

const key = createKey(myModel, defaultState);

const key2 = createKey(myModel2);

const keys = {key, key2};

const Child = ()=>{
    // link the store of key
    useModel(keys.key);
    return ......;
}

// object style keys
const Component = provide(keys)(function Component(){
    // link the store of key2
    useModel(key2, defaultState);
    return <Child/>
});

// array style keys
const Component1 = provide([key, key2])(function Component1(){
    return <Child/>;
})
```

Want a Component `provide` style?

```ts
import {myModel} from './model';
import {createKey, Provider} from '@airma/react-state';

const modelKey = createKey(myModel)

const Component = function Component(){
    return (
        <Provider keys={modelKey}>
            ......
        </Provider>
    );
})
```

`Provider` system uses a distributed store persist strategy, these distributed stores are composed to be a tree structure. So, a model key always finds Provider store from nearest to the top one.

```ts
import {myModel, myModel2} from './model';
import {createKey, provide} from '@airma/react-state';

const key = createKey(myModel, defaultState);

const key2 = createKey(myModel2);

const Child = provide(key2)(()=>{
    // link the store of key,
    // no matched store in `provide(key2)`,
    // then find in a higher provider,
    // and matched in `provide(key)`
    useModel(key);
    useModel(key2, defaultState);
    return ......;
});

const Component = provide(key)(function Component(){
    useModel(key);
    return <Child/>;
});
```

Want same model, different stores?

```ts
import {myModel} from './model';
import {createKey, provide} from '@airma/react-state';

const key = createKey(myModel);

const key2 = createKey(myModel);

// key and key2 are different keys,
// they are from same model `myModel`,
// that makes two different stores
const keys = {key, key2};

const Component = provide(keys)(function Component(){
    return ......;
});
```

## useControlledModel

This API `useControlledModel` can be used in controlled component, like:

Common model:

```ts
export const toggleModel = (selected:boolean)=>([
    selected,
    ()=>!selected
] as const);
```

Use in un-controlled component:

```ts
import {toggleModel} from '../common/model';
import {useModel} from '@airma/react-state';

const UnControlledCheckbox = ()=>{
    const [
        selected,
        toggle
    ] = useModel(
        toggleModel, 
        false
    );

    return ......;
}
```

Use in controlled component:

```ts
import {toggleModel} from '../common/model';
import {useControlledModel} from '@airma/react-state';

const ControlledCheckbox = (props:{
    checked:boolean,
    onChange:(checked:boolean)=>void
})=>{
    const {checked, onChange} = props;
    const [
        selected,
        toggle
    ] = useControlledModel(
        toggleModel,
        // set the controlled state from props 
        checked, 
        // set the controlled onChange from props
        onChange
    );

    return ......;
}
```

Auto controlled compnent:

```ts
import {toggleModel} from '../common/model';
import {useControlledModel} from '@airma/react-state';

const Checkbox = (props:{
    checked?:boolean,
    onChange?:(checked:boolean)=>void
})=>{
    const {checked, onChange} = props;

    const handleChange = (c: boolean)=>{
        onChange?.(c);
    }
    const instance = useModel(
        toggleModel, 
        checked ?? false
    );
    const cInstance = useControlledModel(
        toggleModel,
        checked ?? false, 
        handleChange
    );

    const isUnControlled = 'checked' in props;

    const [
        selected,
        toggle
    ] = isUnControlled? instance : cInstance;

    return ......;
}
```

API `useControlledModel` accepts a model function, a controlled state and a change callback for this controlled state as parameters.

```ts
const instance = useControlledModel(modelFn, value, onChange)
```

## model

API `model` is a simplify API to use APIs refered before. It accepts a model function, returns a similar model function with APIs inside.

```ts
import {model} from '@airma/react-state';

const toggleModel = model((selected:boolean)=>([
    selected,
    ()=>!selected
] as const));

const toggleStore = toggleModel.createStore(false);

const toggleGlobalStore = toggleStore.asGlobal();
......
toggleModel.useModel(false);
toggleModel.useControlledModel(props.checked, props.onChange);
......
toggleStore.provideTo(function Component(){
    const [, toggle] = toggleStore.useModel();
    const selected = toggleStore.useSelector(([s])=>s);
    const selectedInGlobal = toggleGlobalStore.useSelector(([s])=>s);
    return ......;
});
......
function Comp(){
    toggleGlobalStore.useModel();
    return ......;
}
```

The `model` API support global store usage, in that case, no provider is needed.

Want more store in one provider?

```ts
import {model} from '@airma/react-state';

const toggleStore = model((selected:boolean)=>([
    selected,
    ()=>!selected
] as const)).createStore(false);

const countStore = model((count:number)=>([
    count,
    ()=>count+1,
    ()=>count-1
] as const)).createStore(0);

......
toggleStore.with(countStore,...).provideTo(
    function Component(){
        const [, toggle] = toggleStore.useModel();
        const selected = toggleStore.useSelector(([s])=>s);
        const [count, increase, decrease] = countStore.useModel();
        return ......;
    }
);
......
```

API `model` is more simple and useful, the output from `model(myModelFn)` is still a model function, it still can be used in other model functions.

## ConfigProvider

For `@airma/react-state` uses subscription mode to synchronous state changes, it needs a batch update way to update multiple state changes.

Before react<18.0.0, provide `unstable_batchedUpdates` from `react-dom` to `@airma/react-state` can make subscription state updating work more effectively. 

```ts
import { unstable_batchedUpdates } from 'react-dom';
import { ConfigProvider } from '@airma/react-state';

const config = {batchUpdate: unstable_batchedUpdates};

<ConfigProvider value={config}>
......
</ConfigProvider>
```

Next Page [feature](/react-state/feature).



