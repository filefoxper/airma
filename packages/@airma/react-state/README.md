[![npm][npm-image]][npm-url]
[![NPM downloads][npm-downloads-image]][npm-url]
[![standard][standard-image]][standard-url]

[npm-image]: https://img.shields.io/npm/v/%40airma/react-state.svg?style=flat-square
[npm-url]: https://www.npmjs.com/package/%40airma/react-state
[standard-image]: https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat-square
[standard-url]: http://npm.im/standard
[npm-downloads-image]: https://img.shields.io/npm/dm/%40airma/react-state.svg?style=flat-square


# @airma/react-state

`@airma/react-state` is a simple reducer tool, you can use it to replace `useReducer`, if you want more functions like state synchronization and asynchronous request manage, you can try [use-agent-reducer](https://www.npmjs.com/package/use-agent-reducer).

`@airma/react-state` works like that:

```tsx
import React from 'react';
import {render} from 'react-dom'
import {useModel} from '@airma/react-state';

function App(){
    const {count, increase, decrease} = useModel((state:number)=>{
        const baseState = state >= 0? state : 0;
        return {
            count: baseState,
            increase(){
                return baseState + 1;
            },
            decrease(){
                return baseState - 1;
            }
        };
    },0);
    return (
        <div>
            <button onClick={decrease}>-</button>
            <span>{count}</span>
            <button onClick={increase}>+</button>
        </div>
    );
}

render(<App/>, document.getElementById('root'));
```

It calls the model generate function when component is mounting or the model method has been called everytime.

The example above shows how to use API to manage a step counting model. We call `increase` method to generate a next state, then `useModel` update this state by recall model generator again.

So, the state change flow of `increase` is like this:

```
// model function
const model = (state:number)=>{...};

// increase returns
const state = baseState + 1;
// recall model with what increase returns
return model(state);
```

Yes, it is close with `useReducer`, but more free for usage. It looks like `agent-reducer` too, but it support dynamic closure function style, and it is simple enough.

Try not use async methods, `@airma/react-state` will not support that, the target of `@airma/react-state` is supporting react local state manage. We will support transform state from side effect like async request in other ways.

## API

### useModel

* model - model generate function, it accepts a state param, and returns a model object, which contains methods for generating next state and any other properties for describing state.
* state - this is the default state for model initialization. It can be optional, and then the default state is `undefined`.
* option - this is an optional param, you can set it `{refresh: true}` to make param state change always affect current model as a new state. There is a more easy API `useRefreshModel`

returns modelInstance which is generated by calling `model(state)`.  Everytime when a method from modelInstance is called, the result of this method is treated as a next state param, and recalls `model(state)` to refresh modelInstance.

```ts
type AirModelInstance = Record<string, any>;

type AirReducer<S, T extends AirModelInstance> = (state:S)=>T;

function useModel<S, T extends AirModelInstance, D extends S>(
    model: AirReducer<S, T>,
    state?: D,
    option?: {refresh:boolean}
): T
```

### useTupleModel

* model - model generate function, it accepts a state param, and returns a model object, which contains methods for generating next state and any other properties for describing state.
* state - this is the default state for model initialization.
* onChangeOrOption - this is an optional param. If it is a callback, `useTupleModel` goes to a controlled mode, it only accepts state change, and uses `onChange` callback to change next state out, you can use `useControlledModel` to do this too. If it is an option config, you can set `{refresh: true}` to make param state change always affect current model as a new state.

returns the current param state and modelInstance, like `[state, instance]`.

```ts
type AirModelInstance = Record<string, any>;

type AirReducer<S, T extends AirModelInstance> = (state:S)=>T;

function useTupleModel<S, T extends AirModelInstance, D extends S>(
    model: AirReducer<S, T>,
    state: D,
    onChangeOrOption?: ((s:S)=>any)|{refresh:boolean}
): [S, T]
```

With this api, you can split state and methods like:

```tsx
const [count, {increase, decrease}] = useTupleModel((state:number)=>{
    return {
        increase(){
            return state + 1;
        },
        decrease(){
            return state - 1;
        }
    };
},0);
```

### useControlledModel

* model - model generate function, it accepts a state param, and returns a model object, which contains methods for generating next state and any other properties for describing state.
* state - this is the state for model, model can only update this state by `onChange` callback.
* onChange - this is a callback for updating state to an outside state management, like `useState` API.

```ts
type AirModelInstance = Record<string, any>;

type AirReducer<S, T extends AirModelInstance> = (state:S)=>T;

function useControlledModel<
  S,
  T extends AirModelInstance,
  D extends S
>(model: AirReducer<S, T>, state: D, onChange: (s: S) => any): T
```

With this API, you can use your model function more free, and more reusable. This API is against `useModel`, `useModel` maintains state inside a model system, `useControlledModel` is always controlled by input `value, onChange` interfaces.

```tsx
// model.ts
export const counter = (count:number)=>{
    return {
        count,
        increase(){
            return count + 1;
        },
        decrease(){
            return count - 1;
        }
    };
};

//......

// component.ts
import {useControlledModel} from '@airma/react-state';
import {counter} from './model';

const MyComp = ({
  value, 
  onChange
  }:{
    value:number, 
    onChange:(v:number)=>void
  })=>{
  const {
    count, 
    increase, 
    decrease
  } = useControlledModel(counter, value, onChange);
  return ...... 
}

function App(){
  const [value, setValue] = useState<number>(0);

  return (
    <div>
      <MyComp value={value} onChange={setValue}/>
      <div>{value}</div>
    </div>
  );
}
```

### useRefreshModel

* model - model generate function, it accepts a state param, and returns a model object, which contains methods for generating next state and any other properties for describing state.
* state - this is the state outside for model. When this param changes, the model refreshes with it as a new state.

returns a model instance like `useModel`, but can be refreshed by state param too.

```ts
export function useRefreshModel<S, T extends AirModelInstance, D extends S>(
  model: AirReducer<S, T>,
  state: D
): T;
```

When the param state changes, model instance is refreshed by the new state param.

### useRefresh

* method - the method from model instance.
* params - the params of the method, it is an array for method parameters.


```ts
export declare function useRefresh<T extends (...args: any[]) => any>(
  method: T,
  params: Parameters<T>
):void;
```
When the some of the params change, the method is called with these params.

### requireModels

* requireFn - It is a model store generator callback, you can return an object or a model function as model store. The requireFn param callback `hold` is important to make sure the end model function can be accessed as a persistent model. You can pass your model function and `defaultState` into `hold`.

```ts
export declare function requireModels<
  T extends Array<any> | ((...args: any) => any) | Record<string, any>
>(requireFn: (hold: HoldCallback) => T): T;
```

This API is for create a model store, it can be used with `RequiredModelProvider`, and make the state global possible.

ex:

```tsx
import {
  requireModels,
  RequiredModelProvider,
  useRequiredModel
} from '@airma/react-state';

const model = (state:number) => 
({count: state,increase: ()=>state+1});

// persist model and default state with hold
const factory = requireModels((hold)=>hold(model, 0));

......

const Child1 = ()=>{
  // use the holded factory to access the model function
  const {count, increase} = useRequiredModel(factory);
  return (
    <div> ...... </div>
  );
}

const Child2 = ()=>{
  const {count, increase} = useRequiredModel(factory);
  return (
    <div> ...... </div>
  );
}

const App = ()=>{
  // pass factory to Provider as a context
  return (
    <RequiredModelProvider value={factory}>
      <Child1/>
      <Child2/>
    </RequiredModelProvider>
  );
}
```

or 

```tsx
import {
  requireModels,
  RequiredModelProvider,
  useRequiredModel
} from '@airma/react-state';

const model = (state:number) => 
({count: state,increase: ()=>state+1});

// persist model and default state with hold
// you can create an object to organize your model store
const factory = requireModels((hold)=>({
  increase: hold(model, 0),
  addition: hold(model, 0)
  }));

......

const Child1 = ()=>{
  // use the holded value to access your model function
  const {count, increase} = useRequiredModel(factory.increase);
  return (
    <div> ...... </div>
  );
}

const Child2 = ()=>{

  const {count, increase} = useRequiredModel(factory.increase);
  return (
    <div> ...... </div>
  );
}

const Child3 = ()=>{
  // The hold always generates a new model function,
  // so, the addition is a different model function with increase
  const {count, increase} = useRequiredModel(factory.addition);
  return (
    <div> ...... </div>
  );
}

const App = ()=>{
  return (
    <RequiredModelProvider value={factory}>
      <Child1/>
      <Child2/>
      <Child3/>
    </RequiredModelProvider>
  );
}
```

### RequiredModelProvider

* value - model store created by `requireModels` API.
* children - react nodes.

return react nodes.

```tsx
export declare const RequiredModelProvider: FC<{
  value: Array<any> | ((...args: any) => any) | Record<string, any>;
  children: ReactNode;
}>;
```

This provider creates a React Context to link with model store, and you can use model from this store to share `state` and `model` in different child components without props flow help.

### useRequiredModel

* model - a model generate function from store.
* state - a default state for a local model, if the store is not link into a parent `RequiredModelProvider`.

return a model instance from model store, if the store is not used in any parent `RequiredModelProvider`, it creates a local one with the param state.

```tsx
import {
  requireModels,
  RequiredModelProvider,
  useRequiredModel
} from '@airma/react-state';

const model = (state:number) => 
({count: state,increase: ()=>state+1});

// persist model and default state with hold
// you can create an object to organize your model store
const factory = requireModels((hold)=>({
  increase: hold(model, 0)
}));

const factory2 = requireModels((hold)=>({
  increase: hold(model, 0)
}));

......

const Child1 = ()=>{
  // use the holded value to access your model function
  const {count, increase} = useRequiredModel(factory.increase);
  return (
    <div> ...... </div>
  );
}

const Child2 = ()=>{
  // useRequiredModel find model function from a tree built by 
  // `RequiredModelProvider`s.
  const {count, increase} = useRequiredModel(factory.increase);
  return (
    <div> ...... </div>
  );
}

const Child3 = ()=>{
  // factory2 is not linked into a parent RequiredModelProvider,
  // it create a local model function by factory2.increase.
  const {count, increase} = useRequiredModel(factory2.increase,0);
  return (
    <div> ...... </div>
  );
}

const App = ()=>{
  return (
    <RequiredModelProvider value={factory}>
      <Child1/>
      <RequiredModelProvider value={factory}>
        <Child2/>
      </RequiredModelProvider>
      <Child3/>
    </RequiredModelProvider>
  );
}
```

## Tips

The `state` property of model object is not necessary, it can be ignored, you can have some properties as you wish.

```tsx
import React from 'react';
import {render} from 'react-dom'
import {useModel} from '@airma/react-state';

function App(){
    const {count, isNegative, increase, decrease} = useModel((state:number)=>{
    return {
      count: state,
      isNegative: state<0,
      increase(){
        return state + 1;
      },
      decrease(){
        return state - 1;
      }
    };
  },0);

  return (
    <div>
      <div>react state ex 1</div>
      <div>
        <button onClick={decrease}>-</button>
          <span style={isNegative?{color:'red'}:undefined}>{count}</span>
        <button onClick={increase}>+</button>
      </div>
    </div>
  );
}

render(<App/>, document.getElementById('root'));
```

The model function can return almost every model extends `Record<string|number, any>`. Yes, you can write a tuple model if you wish.

```tsx
import React from 'react';
import {render} from 'react-dom'
import {useModel} from '@airma/react-state';

const toggleModel = (v:boolean):[boolean, ()=>boolean] =>[ v, ()=>!v ];

function App(){
    const [visible, toggle] = useModel(toggleModel,false);
    return (
        <div>
            <button onClick={toggle}>toggle</button>
            <span style={!visible?{display:'none'}:undefined}>
              hellow world
            </span>
        </div>
    );
}

render(<App/>, document.getElementById('root'));
```

As we can see it is very easy to describe state properties for usage.

## Persistent methods

The methods from `useModel` returns is persistent, so, you can pass it to a memo component directly, it can improve your app performance.

## Update data out of model function

Yes, the methods are persistent, but the model function still can work with the data out of model when the model function is triggered by methods. They can be updated into model in time.

## Secure reduce state

The API from `useTupleModel`(without onChange) like `useModel`, `useRefreshModel` are secure for state update. The state is outside of react system, so every update from methods is a secure reducing process. If you want to use `useState` to replace its job, you have to call it like: `setState((s)=>s+1)`.

## typescript check

`@airma/react-state` is a typescript support library, you can use it with `typescript` for a better experience. 

It checks if the input `state` type is same with the param default `state` type. 

If the method returning type is same with param default `state` type, and so on.

## End

We hope you can enjoy this tool, and help us to enhance it in future.

